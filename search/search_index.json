{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Swift Package Manager For Kotlin Multiplatform","text":"<p>The Swift Package Manager for Kotlin Multiplatform Plugin, aka <code>spmForKmp</code> Gradle Plugin, is an alternative of the dying CocoaPods Plugin used by KMP cocoapods plugin.</p> <p>It will help you to integrate Swift Package and simplify communication between Swift/Kotlin Multiplatform projects targeting the Apple platform.</p> <p>The plugin uses the embedded Swift Package Manager, so no third-party dependency is needed, and it's less intrusive than CocoaPods.</p> <p>Please Be Aware</p> <p>Pure Swift packages can't be exported to Kotlin; the plugin will help you to create a bridge to bypass this issue.</p> <p>It's a manual job, but until the Swift-import is (not currently planned) available in KMP, it's the only way.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Create a Swift&lt;-&gt;Kotlin bridge: Import your own Swift code for functionality that can't be done in Kotlin.</li> <li>Use SPM third-Party Dependency: Add external dependency and use it inside your bridge</li> <li>Import Swift-compatible code to Kotlin: Enable SPM dependencies and your own Swift code to be exposed directly in your Kotlin code (if compatible).</li> </ul>"},{"location":"#support-my-project","title":"Support My Project \u2b50\ufe0f","text":"<p>If you find this project useful, please consider giving it a star!</p> <p></p>"},{"location":"#feedback","title":"Feedback","text":"<p>This project greatly needs feedback, feature requests, and information about the edge case for progressing; let's talk.</p>"},{"location":"#example","title":"Example","text":"<p>A sample is available for people wanted to see the usage.</p>"},{"location":"bridge/","title":"Bridge The Native API","text":""},{"location":"bridge/#gradle","title":"Gradle","text":"<p>The following configuration is a simple bridge between Kotlin and the Swift Apple Native SDK.</p> build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n    }\n}\n</code></pre> <p>When syncing the project, the plugin creates a folder at <code>src/swift/[cinteropname]</code>.</p> <p>The content of this folder is your bridge between Swift and Kotlin, everything inside is copied to the build directory.</p>"},{"location":"bridge/#example","title":"Example","text":"<p>Make your Swift code compatible with Kotlin.</p> <p>Your Swift code needs to be marked as @objc/@objcMembers and the visibility set as <code>public</code> or it won't be exported and available from your Kotlin code.</p> <p>Some tips here.</p> src/swift/[cinteropname]/mySwiftFile.swift<pre><code>import UIKit\n\n@objcMembers public class MySwiftBridge: NSObject {\n    public func exportedMethod() -&gt; String {\n        return \"value\"\n    }\n    public func exportedView() -&gt; NSObject {\n        return UIView()\n    }\n}\n</code></pre> iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import [cinteropname].MySwiftBridge\n\nval contentFromSwift = MySwiftBridge().exportedMethod()\n\nval aView = MySwiftBridge().exportedView() as UIView\n</code></pre>"},{"location":"bridgeWithDependencies/","title":"Use External Dependencies","text":""},{"location":"bridgeWithDependencies/#how-it-works","title":"How It works","text":"<p>On completion with the basic configuration, it's possible to use external dependency with your bridge.</p> <p>The Plug-in reproduces the CocoaPods plugin behavior with the same kind of issues about third-party dependency but less intrusively.</p> <p>Note</p> <p>If your package doesn't work with the plugin, please create an issue.</p>"},{"location":"bridgeWithDependencies/#supported-dependency-sources","title":"Supported Dependency Sources","text":"<p>The plugin supports the following configurations :</p> VersionCommitBranchLocalLocal BinaryRemote Binary <pre><code>remotePackageVersion(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    version = \"1.8.4\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n)\n</code></pre> <pre><code>remotePackageCommit(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    revision = \"729e01bc9b9dab466ac85f21fb9ee2bc1c61b258\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n)\n</code></pre> <pre><code>remotePackageBranch(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    branch = \"main\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n),\n</code></pre> <pre><code>localPackage(\n    path = \"Absolute path to the local package folder\",\n    packageName = \"LocalSourceDummyFramework\",\n    products = {\n        add(\"LocalSourceDummyFramework\")\n    },\n),\n</code></pre> <pre><code>localBinary(\n    path = \"/path/to/LocalFramework.xcframework\"\n    packageName = \"LocalFramework\"\n),\n</code></pre> <pre><code>remoteBinary(\n    url = URI(\"https://.../RemoteBinaryFramework.xcframework.zip\"),\n    checksum = \"[checksum]\",\n    packageName = \"RemoteBinaryFramework\",\n)\n</code></pre> <p>SwiftDependency reference</p>"},{"location":"bridgeWithDependencies/#xcframework","title":"XCFramework","text":"<p>The XCFramework are used for Local/Remote Binary and protecting source code distribution, learn more.</p> <p>An example is available.</p>"},{"location":"bridgeWithDependencies/#gradle","title":"Gradle","text":"<p>The following configuration imports the package CryptoSwift which is a pure Swift library, that can't be used directly in Kotlin. build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n        dependency {\n            remotePackageVersion(\n                url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n                products = {\n                    add(\"CryptoSwift\")\n                },\n                version = \"1.8.4\",\n            )\n            // Another SwiftDependency\n            // ...\n        }\n    }\n}\n</code></pre></p> <p>Warning</p> <p>A local swift package is being generated during the build and this message displayed <pre><code>Spm4Kmp: A local Swift package has been generated at\n/path/to/the/local/package\nPlease add it to your xcode project as a local package dependency.\n</code></pre> Add the folder to your Xcode project as a Local package, that's all.</p> <p>Note : When updating your configuration, reset the package cache to apply the modification.</p>"},{"location":"bridgeWithDependencies/#example","title":"Example","text":"<p>Make your Swift code compatible with Kotlin.</p> <p>Your Swift code needs to be marked as @objc/@objcMembers and the visibility set as <code>public</code> or it won't be exported and available from your Kotlin code.</p> src/swift/[cinteropname]/mySwiftFile.swift<pre><code>import Foundation\nimport CryptoSwift\n\n@objcMembers public class MySwiftBridge: NSObject {\n    public func toMD5(value: String) -&gt; String {\n        return value.md5()\n    }\n}\n</code></pre> iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import [cinteropname].MySwiftBridge\n\nval contentFromSwift = MySwiftBridge().toMD5(value = \"someString\")\n</code></pre>"},{"location":"exportingDependencies/","title":"Export Dependencies To Kotlin","text":""},{"location":"exportingDependencies/#how-it-works","title":"How It works","text":"<p>On completion with using external dependencies, it's possible to export them to Kotlin, if they are compatible.</p> <p>Exported dependency can be used inside the bridge, the Swift &amp; Kotlin App.</p> <p>Note</p> <p>If your package doesn't work with the plugin, please create an issue.</p>"},{"location":"exportingDependencies/#bridge-incompatible-dependencies","title":"Bridge Incompatible Dependencies","text":"<p>In a case the exported dependency is written in Swift, manual work needs to be done like this.</p> <p>For example, the CryptoSwift can't work directly on Kotlin, so the Plugin's bridge is here to fill the hole between Kotlin and Swift.</p>"},{"location":"exportingDependencies/#gradle","title":"Gradle","text":"<p>The following configuration export to Kotlin the package FirebaseAnalytics which is a ObjC library.</p> <p>Don't export incompatible library</p> <p>Exporting an incompatible library is useless and will only increase build time.</p> build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n        dependency {\n            remotePackageVersion(\n                url = URI(\"https://github.com/firebase/firebase-ios-sdk.git\"),\n                products = {\n                    add(\"FirebaseAnalytics\", exportToKotlin = true), // exported\n                    add(\"FirebaseCore\") // non-exported\n                },\n                version = \"11.8.0\",\n            )\n            // Another SwiftDependency\n            // ...\n        )\n    }\n}\n</code></pre> <p>Warning</p> <p>A local swift package is being generated during the build and this message displayed <pre><code>Spm4Kmp: A local Swift package has been generated at\n/path/to/the/local/package\nPlease add it to your xcode project as a local package dependency.\n</code></pre> Add the folder to your Xcode project as a Local package, that's all.</p> <p>Note : When updating your configuration, reset the package cache to apply the modification.</p>"},{"location":"exportingDependencies/#example","title":"Example","text":"iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import FirebaseAnalytics.FIRConsentStatusGranted\n\n@ExperimentalForeignApi\nval consentStatusGranted = FIRConsentStatusGranted\n</code></pre> <p>Note</p> <p>The bridge can remain empty as we don't need it; we only want to use the exported product.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#whats-a-pure-swift-package","title":"What's a Pure Swift Package ?","text":"<p>The Pure word means the Package is written only in Swift, like 90% of the existing package.</p> <p>The Swift language is commonly used in the Apple Platform and is not compatible with KMP, but only with ObjC.</p> <p>Unlike Kotlin with Java, the interoperability between Swift and ObjC needs to be explicitly declared, but it's like a downgrade, and nobody want to do that.</p> <p>Some old libraries, like Firebase, are mainly written in ObjC or a few of them want to have the compatibility with ObjC.</p> <p>So mainly, Apple's Platforms libraries are written in Swift; you can check inside their repository, the\u00a0Languages\u00a0section to see which language they are using.</p> <p>But sometimes, like google nearby, a wrapper Swift &lt;- ObjC is made to increase the compatibility with Swift and make it unexportable to Kotlin.</p>"},{"location":"faq/#when-exporting-a-product-i-have-only-swift_typedefs-or-swift_-available-in-my-kotlin-code","title":"When exporting a product I have only SWIFT_TYPEDEFS or swift_... available in my Kotlin code.","text":"<p>That means your product is not compatible with ObjC.</p> <p>During the compilation of the package, the Swift compiler generates an ObjC header with all compatible code.</p> <p>The exported ObjC code can be found inside <pre><code>[project]/build/spmKmpPlugin/[cinteropName]/scratch/release/[product].build/module.modulemap\n</code></pre></p> <p>or</p> <pre><code>[project]/build/spmKmpPlugin/[cinteropName]/scratch/release/[product].framework/Modules/module.modulemap\n</code></pre> <p>This module contains every available ObjC header inside the Package.</p> <p>A Pure Swift package has only generic content like <code>SWIFT_TYPEDEFS</code>.</p>"},{"location":"issues/","title":"Known Issues","text":""},{"location":"issues/#coming-not-soon","title":"Coming (not?) soon","text":""},{"location":"license/","title":"License","text":"<p>The MIT License (MIT) Copyright (c) 2025 Fran\u00e7ois Dabonot</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#requirement","title":"Requirement","text":"<ul> <li>macOS With Xcode 16 and later<ul> <li>Using an earlier version of Xcode is possible, but I don't recommend it.</li> </ul> </li> <li>Kotlin : 2.1.0 and later</li> <li>Gradle : 8.10 and later</li> </ul>"},{"location":"setup/#plugins","title":"Plugins","text":"build.gradle.kts<pre><code>plugins {\n    id(\"org.jetbrains.kotlin.multiplatform\")\n    id(\"io.github.frankois944.spmForKmp\") version \"[version]\"\n}\n</code></pre>"},{"location":"setup/#gradle-properties","title":"Gradle Properties","text":"gradle.properties<pre><code>kotlin.mpp.enableCInteropCommonization=true\n</code></pre>"},{"location":"setup/#initial-configuration","title":"Initial Configuration","text":"build.gradle.kts<pre><code>kotlin {\n    listOf(\n        iosArm64(),\n        iosSimulatorArm64()\n        // and more Apple targets...\n    ).forEach {\n        it.compilations {\n            val main by getting {\n                // Choose the cinterop name\n                cinterops.create(\"[cinteropName]\")\n            }\n        }\n    }\n}\n</code></pre> <p>swiftPackageConfig reference build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") { // must match with cinterops.create name\n    }\n}\n</code></pre></p>"},{"location":"tips/","title":"Tips","text":""},{"location":"tips/#reduce-build-time","title":"Reduce Build Time","text":"<ul> <li>Since the version 0.4.0</li> </ul> <p>spmWorkingPath has been added to change the path to Swift Package working file.</p> <p>By setting spmWorkingPath outside the build folder, the working files won't be removed if you clean the project, and you can exclude the folder from indexing.</p> <p>Swift Package Manager has its own cache, so it's fine to detach it from the Kotlin build folder.</p>"},{"location":"tips/#cicd-caching","title":"CI/CD Caching","text":"<p>Add to your cache the content of the <code>build/spmKmpPlugin</code> folder or the <code>spmWorkingDir</code> value if set.</p> <p>Also, check my GitHub action workflow where I build the example app with cached built files.</p>"},{"location":"tips/#firebase","title":"Firebase","text":"<p>An full example of how to implement Firebase with the plugin</p>"},{"location":"tips/#working-with-objcnamesclasses-types","title":"Working With 'objcnames.classes' Types","text":"<p>For example, when using a UIView (work with any ObjC Types, ex: UIViewController...).</p> <p>mySwiftBridge.swift<pre><code>// Force cinterop to include `platform.UIKit.UIView`\n@objcMembers public class MyDummyView: UIView {}\n\n// Or force by inheritance\n@objcMembers public class TestClass: NSObject /* or UIView */ {\n\n    // return `UIView` is not enough to let cinterop use the correct type\n    public func getView() -&gt; UIView {\n        return UIView()\n    }\n\n    public func setView(view: UIView) {\n        // store view\n    }\n\n    // or if you don't want to declare an extra MyDummyView\n\n    public func getViewWithNSObject() -&gt; NSObject {\n        return UIView()\n    }\n\n    public func setViewWithNSObject(view: NSObject) {\n        // store view\n    }\n\n}\n</code></pre> iosMain/myKotlinFile.kt<pre><code>fun getView(): UIView = TestClass().getView()\nfun setView(view: UIView) = TestClass().setViewWithView(view)\n\n// or\n\nfun getView(): UIView = TestClass().getViewWithNSObject() as UIView\nfun setView(view: UIView) = TestClass().setViewWithNSObject(view)\n</code></pre></p>"},{"location":"tips/#support-xcode-15-and-earlier","title":"Support Xcode 15 and earlier","text":"<p>Experimental</p> <p>This is experimental; this tips is not fully tested for every use cases. You can create an issue if needed.</p> <p>As Xcode &lt; 16 is unstable with Swift Package and has some weird behavior. It's recommended to use the latest version of the IDE.</p> <p>But, it is possible to support older versions of Xcode by using a more recent version of the Swift Compiler than the Xcode one.</p> <p>The property swiftBinPath has been added to change the swift command used by the plugin.</p> <p>This official tool swiftly has been recently added to easily install another version of swift on macOS.</p> <p>So follow the swiftly guide to install another swift version and set the swiftBinPath property correctly.</p> <pre><code>swiftBinPath = \"/path/to/.swiftly/bin/swift\"\n</code></pre>"},{"location":"references/bridgeSettingsConfig/","title":"BridgeSettingsConfig","text":""},{"location":"references/bridgeSettingsConfig/#example","title":"Example","text":"<pre><code>bridgeSettings {\n    cSetting {\n        defines = listOf(Pair(\"C_DEBUG\", \"2\"))\n        headerSearchPath = listOf(\"./includes/\")\n        unsafeFlags = listOf(\"-W\")\n    }\n    cxxSetting {\n        defines = listOf(Pair(\"CXX_DEBUG\", \"1\"))\n        headerSearchPath = listOf(\"./includes/\")\n        unsafeFlags = listOf(\"-W\")\n    }\n    linkerSetting {\n        linkedFramework = listOf(\"UIKit\")\n        linkedLibrary = listOf(\"-W\")\n        unsafeFlags = listOf(\"-W\")\n    }\n    swiftSettings {\n        defines = listOf(\"CUSTOM_DEFINE\")\n        enableExperimentalFeature = \"CImplementation\"\n        enableUpcomingFeature = \"ExistentialAny\"\n        interoperabilityMode = \"Cxx\"\n    }\n}\n</code></pre>"},{"location":"references/bridgeSettingsConfig/#csetting","title":"cSetting","text":"<p>The target\u2019s C build settings.</p> <p>Swift Reference</p> <pre><code>public fun cSetting(setting: CSettingConfig.() -&gt; Unit)\n</code></pre>"},{"location":"references/bridgeSettingsConfig/#cxxsetting","title":"cxxSetting","text":"<p>The target\u2019s C++ build settings.</p> <p>Swift Reference</p> <pre><code>public fun cxxSetting(setting: CxxSettingConfig.() -&gt; Unit)\n</code></pre>"},{"location":"references/bridgeSettingsConfig/#swiftsettings","title":"swiftSettings","text":"<p>The target\u2019s Swift build settings.</p> <p>Swift Reference</p> <pre><code>public fun swiftSettings(setting: SwiftSettingConfig.() -&gt; Unit)\n</code></pre>"},{"location":"references/bridgeSettingsConfig/#linkersetting","title":"linkerSetting","text":"<p>The target\u2019s linker settings.</p> <p>Swift Reference</p> <pre><code>public fun linkerSetting(setting: LinkerSettingConfig.() -&gt; Unit)\n</code></pre>"},{"location":"references/swiftPackageConfig/","title":"SwiftPackageConfig","text":""},{"location":"references/swiftPackageConfig/#custompackagesourcepath","title":"customPackageSourcePath","text":"<p>Specifies the custom source path for the Swift package in the Kotlin Multiplatform project.</p> <p>By default, this path is set to the <code>src/swift</code> directory within the project's root directory. This property allows defining a different directory for the Swift package source files, enabling customized project structure organization.</p> <pre><code>var customPackageSourcePath: String = Path(project.projectDir.path, \"src\", \"swift\").pathString\n</code></pre>"},{"location":"references/swiftPackageConfig/#minios","title":"minIos","text":"<p>Specifies the minimum iOS platform version required for the Swift package integration.</p> <p>This property determines the deployment target for the iOS platform when building the Swift package within the Kotlin Multiplatform project. Modifying this value adjusts the generated build configuration and compatibility of the resulting package with iOS devices and emulators.</p> <p>Default value: <code>12.0</code></p> <pre><code>var minIos: String = DEFAULT_MIN_IOS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#minmacos","title":"minMacos","text":"<p>Specifies the minimum supported macOS version for the Swift Package Manager (SPM) integration.</p> <p>This property defines the macOS version targeted by the Swift package and its dependencies. Used during the generation of SPM manifests and the compilation of Swift packages to ensure compatibility with the specified macOS version.</p> <p>Default value: <code>10.13</code></p> <pre><code>var minMacos: String = DEFAULT_MIN_MAC_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#mintvos","title":"minTvos","text":"<p>Specifies the minimum required version of tvOS for the Swift package definition.</p> <p>This property is used to configure the minimum tvOS version that the Swift package dependencies and targets must support. [ Default value: <code>12.0</code></p> <pre><code>var minTvos: String = DEFAULT_MIN_TV_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#minwatchos","title":"minWatchos","text":"<p>Minimum watchOS version required for the Swift package.</p> <p>This variable is used to specify the minimum version of watchOS that a Swift package targets when building or running tasks involving watchOS-specific code. It ensures compatibility with the defined platform version during build processes or runtime configurations.</p> <p>Default value: <code>4.0</code></p> <pre><code>var minWatchos: String = DEFAULT_MIN_WATCH_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#toolsversion","title":"toolsVersion","text":"<p>Specifies the version of Swift tools that will be utilized. This version determines the compatibility and features available for the Swift Package Manager.</p> <p>The <code>toolsVersion</code> value impacts the structure of the <code>Package.swift</code> manifest file and the behavior of the Swift package dependencies during resolution and compilation.</p> <p>Default value: <code>5.9</code></p> <pre><code>var toolsVersion: String = DEFAULT_TOOL_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#debug","title":"debug","text":"<p>Indicates whether the Swift package is built in debug mode.</p> <p>If set to <code>true</code>, the package is being built with debug configuration. This can be useful for testing or development purposes where debug symbols and additional information are required.</p> <p>Note: release build are faster (apparently...)</p> <p>Default value: <code>false</code></p> <pre><code>var debug: Boolean\n</code></pre>"},{"location":"references/swiftPackageConfig/#packagedependencyprefix","title":"packageDependencyPrefix","text":"<p>Represents a prefix used for resolving conflicts or distinguishing between multiple package dependencies within a Kotlin Multiplatform project. This variable can be utilized to customize or uniquely identify package names or references when required.</p> <p>It is nullable and, when set, the prefix will be applied to all dependencies.</p> <pre><code>var packageDependencyPrefix: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#linkeropts","title":"linkerOpts","text":"<p>Add custom linker flag when exporting the product to kotlin, used by cinterop</p> <pre><code>var linkerOpts: List&lt;String&gt; = emptyList()\n</code></pre>"},{"location":"references/swiftPackageConfig/#compileropts","title":"compilerOpts","text":"<p>Add custom compiler flag when exporting the product to kotlin, used by cinterop</p> <pre><code>var compilerOpts: List&lt;String&gt; = emptyList()\n</code></pre>"},{"location":"references/swiftPackageConfig/#dependency","title":"dependency","text":"<p>Adds one or more Swift dependencies to the dependencies list.</p> <ul> <li>dependencies A configuration block of type <code>DependencyConfig</code>.</li> </ul> <p>The block allows specifying various compiler and linker settings needed for the package build.</p> <p>This can include local or remote dependencies in the form of Swift packages or binary <code>xcframework</code> bundles.</p> <p>It supports different dependency models such as local, versioned remote, branch-based remote, or commit-based remote dependencies.</p> <pre><code>fun dependency(dependencies: DependencyConfig.() -&gt; Unit)\n</code></pre>"},{"location":"references/swiftPackageConfig/#dependency-deprecated","title":"dependency (Deprecated)","text":"<p>Please Be Aware</p> <p>Will be removed on version 1.0.0 and replaced by DependencyConfig</p> <p>Adds one or more Swift dependencies to the dependencies list.</p> <ul> <li>dependency A variable number of <code>SwiftDependency</code> instances to be added.</li> </ul> <p>This can include local or remote dependencies in the form of Swift packages or binary <code>xcframework</code> bundles.</p> <p>It supports different dependency models such as local, versioned remote, branch-based remote, or commit-based remote dependencies.</p> <pre><code>fun dependency(vararg dependency: SwiftDependency)\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedcachepath","title":"sharedCachePath","text":"<p>Specify the shared cache directory path</p> <pre><code>var sharedCachePath: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedconfigpath","title":"sharedConfigPath","text":"<p>Specify the shared configuration directory path</p> <pre><code>var sharedConfigPath: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedsecuritypath","title":"sharedSecurityPath","text":"<p>Specify the shared security directory path</p> <pre><code>var sharedSecurityPath: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#spmworkingpath","title":"spmWorkingPath","text":"<p>The path of the directory where working SPM file(s) will be written.</p> <p>Default : <code>{buildDirectory}/spmKmpPlugin/</code></p> <pre><code>var spmWorkingPath: String\n</code></pre>"},{"location":"references/swiftPackageConfig/#targetsettings","title":"targetSettings","text":"<p>Configures the bridge settings by applying the specified configuration options.</p> <p>This method allows customization of the bridge's build settings by providing a configuration block where settings can be defined for compilers (C, C++, Swift) and linker options. These settings adjust the behavior of the bridge during the build process.</p> <ul> <li>setting A configuration block of type <code>PackageSettingConfig</code>.</li> </ul> <p>The block allows specifying various compiler and linker settings needed for the package build.</p> <pre><code>fun bridgeSettings(setting: BridgeSettingsConfig.() -&gt; Unit)\n</code></pre>"},{"location":"references/swiftPackageConfig/#swiftbinpath","title":"swiftBinPath","text":"<p>The path of the Swift command line used to build the bridge You can change the version of swift used for building the bridge by setting another binary</p> <p>Default : uses the command <code>xcrun --sdk macosx swift</code> by default</p> <pre><code>var swiftBinPath: String? = null\n</code></pre>"},{"location":"references/dependency/dependencyConfig/","title":"DependencyConfig","text":""},{"location":"references/dependency/dependencyConfig/#example","title":"Example","text":"<pre><code>dependency {\n    remotePackageVersion(\n        url = URI(\"https://github.com/appmetrica/appmetrica-sdk-ios\"),\n        version = \"5.0.0\",\n        products = {\n            add(\"AppMetricaCore\", exportToKotlin = true)\n        },\n    )\n}\n</code></pre>"},{"location":"references/dependency/dependencyConfig/#binary-packages","title":"Binary Packages","text":""},{"location":"references/dependency/dependencyConfig/#localbinary","title":"localBinary","text":"<p>Represents a local binary dependency.</p> <p>How to make one</p> <ul> <li>path The local file URL (file://...) to the xcFramework.</li> <li>packageName The name of the package associated with this binary.</li> <li>exportToKotlin Defines whether the dependency should be exported for use in Kotlin code.</li> <li>linkerOpts</li> <li>compilerOpts</li> </ul> <pre><code>fun localBinary(\n    path: String,\n    packageName: String,\n    exportToKotlin: Boolean = false,\n    linkerOpts: List&lt;String&gt; = emptyList(),\n    compilerOpts: List&lt;String&gt; = emptyList(),\n)\n</code></pre>"},{"location":"references/dependency/dependencyConfig/#remotebinary","title":"remoteBinary","text":"<p>Represents a remote binary dependency as a zipped xcFramework</p> <p>How to make one</p> <ul> <li>url The URL pointing to the remote binary artifact.</li> <li>packageName The name of the package associated with this binary dependency.</li> <li>exportToKotlin Defines whether this dependency should be exported for use in Kotlin code.</li> <li>checksum The checksum of the remote binary to verify its integrity.</li> <li>linkerOpts</li> <li>compilerOpts</li> </ul> <pre><code>fun remoteBinary(\n    url: URI,\n    packageName: String,\n    exportToKotlin: Boolean = false,\n    checksum: String,\n    linkerOpts: List&lt;String&gt; = emptyList(),\n    compilerOpts: List&lt;String&gt; = emptyList(),\n)\n</code></pre>"},{"location":"references/dependency/dependencyConfig/#local-remote-package","title":"Local &amp; Remote Package","text":""},{"location":"references/dependency/dependencyConfig/#localpackage","title":"localPackage","text":"<p>Represents a local Swift package dependency.</p> <ul> <li>path The local file URL (file://...) to the local Swift package folder.</li> <li>packageName The name of the package, by default the first product name.</li> <li>products A list of the product's package used during dependency configuration.</li> </ul> <pre><code>fun localPackage(\n    path: String,\n    packageName: String = \"\",\n    products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/dependency/dependencyConfig/#remotepackageversion","title":"remotePackageVersion","text":"<p>Represents a specific version of a remote Swift package.a</p> <ul> <li>url The URL of the remote Git repository where the package is hosted.</li> <li>packageName The name of the package, by default base of the url.</li> <li>version The specific version of the Swift package to be imported.</li> <li>products A list of the product's package used during dependency configuration.</li> </ul> <pre><code>fun remotePackageVersion(\n    url: URI,\n    packageName: String = \"\",\n    version: String,\n    products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/dependency/dependencyConfig/#remotepackagebranch","title":"remotePackageBranch","text":"<p>Represents a branch-based remote Swift dependency.</p> <ul> <li>url The URL of the remote Git repository where the package is hosted.</li> <li>packageName The name of the package, by default base of the url.</li> <li>branch The branch name of the remote Git repository used for the dependency.</li> <li>products A list of the product's package used during dependency configuration.</li> </ul> <pre><code>fun remotePackageBranch(\n    url: URI,\n    packageName: String = \"\",\n    branch: String,\n    products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/dependency/dependencyConfig/#remotepackagecommit","title":"remotePackageCommit","text":"<p>Represents a specific remote commit dependency.</p> <ul> <li>url The URL of the remote Git repository where the package is hosted.</li> <li>packageName The name of the package, by default base of the url.</li> <li>revision A specific commit hash representing the dependency version.</li> <li>products A list of the product's package used during dependency configuration.</li> </ul> <pre><code>fun remotePackageCommit(\n    url: URI,\n    packageName: String = \"\",\n    revision: String,\n    products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/dependency/productName/","title":"ProductName","text":""},{"location":"references/dependency/productName/#productname_1","title":"ProductName","text":"<p>Represents the name of a product, with an optional alias and more to come.</p> <ul> <li>name The name of the product within the Swift package ecosystem. This is required for proper   identification and resolution of the dependency.</li> <li>alias An optional alias that can be used as an alternate reference to the product.   Some Package use indirect name for a product.</li> <li>linkerOpts Add custom linker flag when exporting the product to kotlin</li> <li>compilerOpts Add custom compiler flag when exporting the product to kotlin</li> <li>isIncludedInExportedPackage By default, true declare the product in the exported local package</li> </ul> <pre><code>data class ProductName(\n    val name: String,\n    val alias: String? = null,\n    var linkerOpts: List&lt;String&gt; = emptyList(),\n    var compilerOpts: List&lt;String&gt; = emptyList(),\n    var isIncludedInExportedPackage: Boolean = true,\n) : Serializable\n</code></pre>"},{"location":"references/dependency/productPackageConfig/","title":"ProductPackageConfig","text":""},{"location":"references/dependency/productPackageConfig/#example","title":"Example","text":"<pre><code>remotePackageVersion(\n    url = URI(\"https://github.com/appmetrica/appmetrica-sdk-ios\"),\n    version = \"5.0.0\",\n    products = {\n        add(\"AppMetricaCore\", exportToKotlin = true)\n    },\n)\n// or\nremotePackageVersion(\n    url = URI(\"https://github.com/appmetrica/appmetrica-sdk-ios\"),\n    version = \"5.0.0\",\n    products = {\n        add(ProductName(\"AppMetricaCore\"), exportToKotlin = true)\n    },\n)\n</code></pre>"},{"location":"references/dependency/productPackageConfig/#add-by-productname","title":"Add by ProductName","text":"<p>Adds one or more products to the product package configuration.</p> <ul> <li>products The products to be added. Each product is represented by a [ProductName],   which includes details such as the name and an optional alias.</li> <li>exportToKotlin Determines whether the added products should be exported   to Kotlin. Defaults to <code>false</code> if not specified.</li> </ul> <pre><code>fun add(\n    vararg products: ProductName,\n    exportToKotlin: Boolean = false,\n)\n</code></pre>"},{"location":"references/dependency/productPackageConfig/#add-by-names","title":"Add by Names","text":"<p>Adds one or more product names to the product package configuration using their string representation.</p> <ul> <li>names The string representations of the product names to be added.   Each string corresponds to the name of the product within the Swift package ecosystem.</li> <li>exportToKotlin Determines whether the added products should be exported   to Kotlin. Defaults to <code>false</code> if not specified.</li> </ul> <pre><code>fun add(\n    vararg names: String,\n    exportToKotlin: Boolean = false,\n)\n</code></pre>"},{"location":"references/dependency/swiftDependency/","title":"SwiftDependency (Deprecated)","text":"<p>Please Be Aware</p> <p>Will be removed on version 1.0.0 and replaced by DependencyConfig</p>"},{"location":"references/dependency/swiftDependency/#swiftdependencypackage","title":"SwiftDependency.Package","text":""},{"location":"references/dependency/swiftDependency/#remote","title":"Remote","text":""},{"location":"references/dependency/swiftDependency/#version","title":"Version","text":"<p>Represents a specific version of a remote Swift package to be used as a dependency in a Kotlin Multiplatform project.</p> <ul> <li>url The URL of the remote Git repository where the package is hosted.</li> <li>products A list of the product's package used during dependency configuration.</li> <li>packageName The name of the package, by default base of the url.</li> <li>version The specific version of the Swift package to be imported .</li> </ul> <pre><code>SwiftDependency.Package.Remote.Version(\n    public override val url: URI,\n    public override val packageName: String = buildPackageName(url),\n    public val version : String,\n    public override val products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/dependency/swiftDependency/#commit","title":"Commit","text":"<p>Represents a specific remote commit dependency for a Swift Package.</p> <ul> <li>url The URL of the remote Git repository where the package is hosted.</li> <li>products A list of the product's package used during dependency configuration.</li> <li>packageName The name of the package, by default base of the url.</li> <li>revision A specific commit hash representing the dependency version .</li> </ul> <pre><code>SwiftDependency.Package.Remote.Commit(\n    public override val url: URI,\n    public override val packageName: String = buildPackageName(url),\n    public val revision : String,\n    override val products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/dependency/swiftDependency/#branch","title":"Branch","text":"<p>Represents a branch-based remote Swift dependency in a Kotlin Multiplatform project.</p> <ul> <li>url The URL of the remote Git repository where the package is hosted.</li> <li>products A list of the product's package used during dependency configuration.</li> <li>packageName The name of the package, by default base of the url.</li> <li>branch The branch name of the remote Git repository used for the dependency .</li> </ul> <pre><code>SwiftDependency.Package.Remote.Branch(\n    public override val url: URI,\n    public override val packageName: String = buildPackageName(url),\n    public val branch : String,\n    override val products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/dependency/swiftDependency/#local","title":"Local","text":"<p>Represents a local Swift package dependency .</p> <ul> <li>path The local file URL (file://...) to the local Swift package folder.</li> <li>packageName The name of the package, by default the first product name.</li> <li>products A list of the product's package used during dependency configuration.</li> </ul> <pre><code>SwiftDependency.Package.Local(\n    val path : String,\n    override var packageName: String = \"\", // by default the first ProductName\n    override val products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/dependency/swiftDependency/#binary","title":"Binary","text":""},{"location":"references/dependency/swiftDependency/#local_1","title":"Local","text":"<p>Represents a local binary dependency in the Kotlin Multiplatform project .</p> <p>How to make one</p> <ul> <li>path The local file URL (file://...) to the xcFramework.</li> <li>packageName The name of the package associated with this binary .</li> <li>exportToKotlin Defines whether the dependency should be exported for use in Kotlin code .</li> </ul> <pre><code>SwiftDependency.Binary.Local(\n    val path : String,\n    override val packageName: String,\n    override val exportToKotlin: Boolean = false,\n    override var linkerOpts: List&lt;String&gt; = emptyList(),\n    override var compilerOpts: List&lt;String&gt; = emptyList(),\n),\n</code></pre>"},{"location":"references/dependency/swiftDependency/#remote_1","title":"Remote","text":"<p>Represents a remote binary dependency as a zipped xcFramework</p> <p>How to make one</p> <ul> <li>url The URL pointing to the remote binary artifact.</li> <li>packageName The name of the package associated with this binary dependency.</li> <li>exportToKotlin Defines whether this dependency should be exported for use in Kotlin code.</li> <li>checksum The checksum of the remote binary to verify its integrity.</li> </ul> <pre><code>SwiftDependency.Binary.Remote(\n    val url: URI,\n    override val packageName: String,\n    override val exportToKotlin: Boolean = false,\n    val checksum: String,\n    override var linkerOpts: List&lt;String&gt; = emptyList(),\n    override var compilerOpts: List&lt;String&gt; = emptyList(),\n)\n</code></pre>"},{"location":"references/targetSettingsConfigs/CSettingConfig/","title":"CSettingConfig","text":"<p>Swift Documentation</p>"},{"location":"references/targetSettingsConfigs/CSettingConfig/#defines","title":"defines","text":"<p>Defines a value for a macro.</p> <pre><code>var defines: List&lt;Pair&lt;String, String?&gt;&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/CSettingConfig/#headersearchpath","title":"headerSearchPath","text":"<p>Provides a header search path relative to the target\u2019s directory.</p> <pre><code>var headerSearchPath: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/CSettingConfig/#unsafeflags","title":"unsafeFlags","text":"<p>Sets unsafe flags to pass arbitrary command-line flags to the corresponding build tool.</p> <pre><code>var unsafeFlags: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/CxxSettingConfig/","title":"CxxSettingConfig","text":"<p>Swift Documentation</p>"},{"location":"references/targetSettingsConfigs/CxxSettingConfig/#defines","title":"defines","text":"<p>Defines a value for a macro.</p> <pre><code>var defines: List&lt;Pair&lt;String, String?&gt;&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/CxxSettingConfig/#headersearchpath","title":"headerSearchPath","text":"<p>Provides a header search path relative to the target\u2019s directory.</p> <pre><code>var headerSearchPath: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/CxxSettingConfig/#unsafeflags","title":"unsafeFlags","text":"<p>Sets unsafe flags to pass arbitrary command-line flags to the corresponding build tool.</p> <pre><code>var unsafeFlags: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/LinkerSettingConfig/","title":"LinkerSettingConfig","text":"<p>Swift Documentation</p>"},{"location":"references/targetSettingsConfigs/LinkerSettingConfig/#linkedframework","title":"linkedFramework","text":"<p>Declares linkage to a system framework.</p> <pre><code>var linkedFramework: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/LinkerSettingConfig/#linkedlibrary","title":"linkedLibrary","text":"<p>Declares linkage to a system library.</p> <pre><code>var linkedLibrary: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/LinkerSettingConfig/#unsafeflags","title":"unsafeFlags","text":"<p>Sets unsafe flags to pass arbitrary command-line flags to the corresponding build tool.</p> <pre><code>var unsafeFlags: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/SwiftSettingConfig/","title":"SwiftSettingConfig","text":"<p>Swift Documentation</p>"},{"location":"references/targetSettingsConfigs/SwiftSettingConfig/#defines","title":"defines","text":"<p>Defines a compilation condition.</p> <pre><code>var defines: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/SwiftSettingConfig/#unsafeflags","title":"unsafeFlags","text":"<p>Set unsafe flags to pass arbitrary command-line flags to the corresponding build tool.</p> <pre><code>var unsafeFlags: List&lt;String&gt;\n</code></pre>"},{"location":"references/targetSettingsConfigs/SwiftSettingConfig/#enableexperimentalfeature","title":"enableExperimentalFeature","text":"<p>Enable an experimental feature with the given name.</p> <pre><code>var enableExperimentalFeature: String?\n</code></pre>"},{"location":"references/targetSettingsConfigs/SwiftSettingConfig/#enableupcomingfeature","title":"enableUpcomingFeature","text":"<p>Enable an upcoming feature with the given name.</p> <pre><code>var enableUpcomingFeature: String?\n</code></pre>"},{"location":"references/targetSettingsConfigs/SwiftSettingConfig/#swiftlanguagemode","title":"swiftLanguageMode","text":"<p>Defines a -language-mode to pass to the corresponding build tool.</p> <p>A user-defined value for the Swift version: 4, 5, 6</p> <p>Available on swift-tools-version &gt; 6.0</p> <p>Reference</p> <pre><code>var swiftLanguageMode: String?\n</code></pre>"},{"location":"references/targetSettingsConfigs/SwiftSettingConfig/#interoperabilitymode","title":"interoperabilityMode","text":"<p>Enable Swift interoperability with a given language.</p> <p>available values : C, Cxx</p> <pre><code>var interoperabilityMode: String?\n</code></pre>"},{"location":"usages/distribution/","title":"Distribute Kotlin Library","text":""},{"location":"usages/distribution/#release-a-library-using-the-plugin","title":"Release A Library Using The Plugin","text":"<p>We can distribute to other users a Kotlin library using native or third-party dependency, some requirements are necessary for Apple targets.</p>"},{"location":"usages/distribution/#requirement","title":"Requirement","text":"<p>The user must :</p> <ul> <li>add the same native dependency used by the Kotlin library to his Xcode project.</li> <li>use the same version as the library use.</li> </ul> <p>It will fix issues with linking, missing resources, App Store compliance, and more.</p> <p>Note</p> <p>The user doesn't have access to the Kotlin library source code, which is great!</p>"},{"location":"usages/distribution/#example","title":"Example","text":"<p>A Compose Multiplatform Component library using a native video player.</p> commonMain/kotlin/KmpPlayer.kt<pre><code>@Composable\npublic expect fun KmpPlayer(modifier: Modifier = Modifier, url: String)\n</code></pre>"},{"location":"usages/distribution/#android","title":"Android","text":"<p>For Android, it uses Exoplayer.</p>"},{"location":"usages/distribution/#gradle","title":"Gradle","text":"library/build.gradle.kts<pre><code>androidMain.dependencies {\n    implementation(libs.media3.exoplayer)\n    implementation(libs.media3.exoplayer.dash)\n    implementation(libs.media3.ui)\n}\n</code></pre>"},{"location":"usages/distribution/#androidmain","title":"AndroidMain","text":"androidMain/kotlin/KmpPlayer.kt<pre><code>@Composable\npublic actual fun KmpPlayer(modifier: Modifier, url: String) {\n\n    val context = LocalContext.current\n\n    // Initialize ExoPlayer\n    val exoPlayer = ExoPlayer.Builder(context).build()\n\n    val mediaSource = remember(url) {\n        MediaItem.fromUri(url)\n    }\n\n\n    LaunchedEffect(url) {\n        exoPlayer.setMediaItem(mediaSource)\n        exoPlayer.prepare()\n    }\n\n    // Manage lifecycle events\n    DisposableEffect(Unit) {\n        onDispose {\n            exoPlayer.release()\n        }\n    }\n\n    AndroidView(\n        factory = { ctx -&gt;\n            PlayerView(ctx).apply {\n                player = exoPlayer\n            }\n        },\n        modifier = modifier\n    )\n}\n</code></pre>"},{"location":"usages/distribution/#ios","title":"iOS","text":"<p>For iOS, it uses KSPlayer, it's a pure Swift library.</p>"},{"location":"usages/distribution/#gradle_1","title":"Gradle","text":"library/build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"appleDeps\") {\n        minIos = \"13.0\"\n        minMacos = \"10.15\"\n        minTvos = \"13.0\"\n        minWatchos = \"2.0\"\n        dependency {\n            remotePackageBranch(\n                url = URI(\"https://github.com/kingslay/KSPlayer\"),\n                products = {\n                    add(\"KSPlayer\")\n                },\n                branch = \"main\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"usages/distribution/#bridge","title":"Bridge","text":"<p>Some tips here.</p> src/swift/appleDeps/MEPlayerController.swift<pre><code>import Foundation\nimport KSPlayer\n\n@objcMembers public class MEPlayerController: NSObject {\n     private let player = IOSVideoPlayerView()\n\n    override init() {\n       super.init()\n       KSOptions.secondPlayerType = KSMEPlayer.self\n       player.delegate = self\n       player.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n       player.contentMode = .scaleAspectFill\n    }\n\n    public func setMediaItem(videoUrl: URL) {\n       player.set(\n          url: videoUrl,\n          options: KSOptions()\n      )\n    }\n\n    public var playerView: NSObject {\n       player\n    }\n\n    public func releasePlayer() {\n       player.resetPlayer()\n       player.removeFromSuperview()\n    }\n}\n</code></pre>"},{"location":"usages/distribution/#iosmain","title":"IOSMain","text":"iosMain/kotlin/KmpPlayer.kt<pre><code>import appleDeps.MEPlayerController\n\n@Composable\npublic actual fun KmpPlayer(modifier: Modifier, url: String) {\n\n    val playerController = MEPlayerController()\n\n    val mediaSource = remember(url) {\n        NSURL.URLWithString(url)\n    }\n\n    LaunchedEffect(url) {\n        if (mediaSource == null) {\n            throw Exception(\"Bad input URL\")\n        }\n        playerController.setMediaItemWithVideoUrl(videoUrl = mediaSource)\n    }\n\n    DisposableEffect(Unit) {\n        onDispose {\n            playerController.releasePlayer()\n        }\n    }\n\n    UIKitView(\n        factory = {\n            playerController.playerView() as UIView\n        },\n        modifier = modifier,\n        update = {\n        }\n    )\n}\n</code></pre>"},{"location":"usages/distribution/#requirement_1","title":"Requirement","text":"<p>The setup guide of your library must contain the rule that KSPlayer package must be added to his Xcode project with the explicit version.</p>"},{"location":"usages/distribution/#sample","title":"Sample","text":"<p>The sample is available.</p> <ul> <li>Run the command <code>./gradlew publishToMavenLocal --no-configuration-cache</code> on the repository root.</li> <li>Open the project <code>sampleApp</code> and test the application</li> </ul>"},{"location":"usages/largebridge/","title":"Working With Large Bridge","text":"<p>If you plan to have a large bridge for using a particular Pure Swift Package, like Stripe, working with an editor without code completion can be difficult.</p> <p>The solution is to work with a local package you will add to your plugin configuration.</p> <p>The big advantage is that you can test your code before adding it to your KMP project.</p>"},{"location":"usages/largebridge/#create-a-local-package","title":"Create A Local Package","text":"<ul> <li>From command line : <code>swift package init --name YouPackageName</code></li> <li>From Xcode : File -&gt; New -&gt; Package -&gt; Library</li> </ul>"},{"location":"usages/largebridge/#choose-your-editor","title":"Choose Your Editor","text":"<p>You can either use Xcode or VSCode with the Swift Plugin; both are fine.</p>"},{"location":"usages/largebridge/#package-manifest","title":"Package Manifest","text":"<p>A Swift Package is based on a Manifest, the Package.swift (official documentation)</p>"},{"location":"usages/largebridge/#example","title":"Example","text":"Package.swift<pre><code>// swift-tools-version: 5.9\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"MyStripeSDK\",\n    platforms: [.iOS(.v14)],\n    products: [\n        // Products define the executables and libraries a package produces, making them visible to other packages.\n        .library(\n            name: \"MyStripeSDK\",\n            targets: [\"MyStripeSDK\"]),\n    ],\n    dependencies: [\n        .package(url: \"https://github.com/stripe/stripe-ios-spm\", .upToNextMajor(from: \"24.5.0\")),\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package, defining a module or a test suite.\n        // Targets can depend on other targets in this package and products from dependencies.\n        .target(\n            name: \"MyStripeSDK\",\n            dependencies: [\n                .product(name: \"Stripe\", package: \"stripe-ios-spm\"),\n                .product(name: \"StripePaymentSheet\", package: \"stripe-ios-spm\")\n            ]),\n        .testTarget(\n            name: \"MyStripeSDKTests\",\n            dependencies: [\n                \"MyStripeSDK\"\n            ]\n        ),\n    ]\n)\n</code></pre>"},{"location":"usages/largebridge/#package-source","title":"Package Source","text":"<p>Usually located at <code>Sources/[packageName]</code>, it has the same requirement as the plugin's bridge source files.</p> <p>Make your Swift code compatible with Kotlin.</p> <p>Your Swift code needs to be marked as @objc/@objcMembers and the visibility set as <code>public</code> or it won't be exported and available from your Kotlin code.</p>"},{"location":"usages/largebridge/#example_1","title":"Example","text":"Sources/MyStripeSDK/Package.swift<pre><code>import StripePaymentSheet\n\n@objcMembers public class MyStripeSDK: NSObject {\n\n    private var paymentSheet: PaymentSheet?\n    private var paymentIntentClientSecret: String\n    private let backendCheckoutUrl = URL(string: \"Your backend endpoint/payment-sheet\")\n\n    public init(paymentIntentClientSecret: String) {\n        self.paymentIntentClientSecret = paymentIntentClientSecret\n    }\n\n    public func doStripeJob() {\n        var configuration = PaymentSheet.Configuration()\n        configuration.merchantDisplayName = \"Example, Inc.\"\n        self.paymentSheet = PaymentSheet(paymentIntentClientSecret: self.paymentIntentClientSecret,\n                                         configuration: configuration)\n    }\n}\n</code></pre>"},{"location":"usages/largebridge/#plugin-configuration","title":"Plugin Configuration","text":"<p>Add your local package to your plugin configuration, follow the guide.</p>"},{"location":"usages/largebridge/#example_2","title":"Example","text":"build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"MyStripeSDKLibs\") {\n        dependency {\n            localPackage(\n                // absolute path to your Local Package\n                path = \"$projectDir/../MyStripeSDK\",\n                packageName = \"MyStripeSDK\",\n                products = {\n                    // Export to Kotlin for use in shared Kotlin code, false by default\n                    add(\"MyStripeSDK\", exportToKotlin = true)\n                }\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"usages/largebridge/#dont-store-sensitive-data","title":"Don't Store Sensitive Data","text":"<p>The local package source is visible</p> <p>If you share this package, don't put sensitive data inside, as it needs to be added to the Xcode project.</p> <p>You can use the default plugin's bridge if needed, as it's not visible from the application or your shared Kotlin library.</p>"},{"location":"usages/multiTarget/","title":"Multi Target Configuration","text":""},{"location":"usages/multiTarget/#configuration-by-target","title":"Configuration By Target","text":"<p>You can set a different configuration for each target you manage.</p> build.gradle.kts<pre><code>listOf(\n    iosX64(),\n    iosSimulatorArm64(),\n).forEach {\n    it.compilations {\n        val main by getting {\n            cinterops.create(\"nativeIosShared\") // a config for iOS\n        }\n    }\n}\n\nlistOf(\n    macosArm64(),\n).forEach {\n    it.compilations {\n        val main by getting {\n            cinterops.create(\"nativeMacosShared\") // a config for macos\n        }\n    }\n}\n\nswiftPackageConfig {\n    create(\"nativeIosShared\") {\n        // your embedded swift is inside the folder src/swift/nativeIosShared\n        // your config for iOS\n    }\n    create(\"nativeMacosShared\") {\n        // your embedded swift is inside the folder src/swift/nativeMacosShared\n        // your config for macOS\n    }\n}\n</code></pre>"}]}